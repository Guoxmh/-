package com.cn;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

//此方法 通过反射可以获取多个对象
class Singleton{
    //确保产生的对象的完整性
    private volatile static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

//枚举写的单例  但枚举就可以做到

public class Test {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(3);

      /*  ExecutorService executorService = Executors.newSingleThreadExecutor();
        ExecutorService executorService1 = Executors.newCachedThreadPool();
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);
       //定时执行
        scheduledExecutorService.schedule(()->{
            System.out.println("你个傻逼");
        },2L,TimeUnit.SECONDS);
        //延时initialDelay时间后  按周期延迟执行任务
        scheduledExecutorService.scheduleWithFixedDelay(()->{
            System.out.println("wanmei");
        },1L,2L,TimeUnit.SECONDS);
        *//*
        * Executors 工具类 有四大线程池
        * 1. newFixedThreadPool()
        * 2. newCachedThreadPool()
        * 3. newsingleThreadExecutor()
        * 4. newScheduledThreadPool()
        *
        * */
    }
}

class Cache{
    static Map<String,Object> map = new HashMap<>();
    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    static Lock readLock  = rwl.readLock();
    static Lock wiriteLock = rwl.writeLock();

    /*
    * 线程安全根据一个key 来获取一个value
    * */

    public static final Object get(String key){
        readLock.lock();;
        try {
            return map.get(key);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readLock.unlock();
        }
        return null;
    }

    /*
    * 线程安全的根据key设置value,并返回旧的value
    * */
    public static  final Object put(String key, Object value){
        wiriteLock.lock();
        try {
            return map.put(key,value);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            wiriteLock.unlock();
        }
        return null;
    }
    /*
    * 线程安全的清空所有的value
    *
    * */

    public static final void clear(){
        wiriteLock.lock();

        try {
            map.clear();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            wiriteLock.unlock();
        }
    }
}

/*
* 线程间通信
* 1. synchronized 的 wait() 和 notify() 和 notifyAll() 方法
* 2. lock 的condition的 await() 和 signal()和signalAll()方法
*
* 同步队列 : 是线程获取锁失败后 线程进去的地方  Lock  非阻塞式获取锁
*
* 等待队列: 是线程获取到锁后,为了等待某种资源 调用wait()等方法进入等待
* 队列   使用notify方法时 他就会唤醒等待对类中的线程  让他进入同步
* 队列中去竞争锁资源 , lock 可以实现多个等待队列  从而可以节省资源提高效率
*
* lock()是阻塞式获取锁
* try() 是非阻塞式获取锁
*
* */